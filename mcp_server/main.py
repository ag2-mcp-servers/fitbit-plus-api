# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T11:21:43+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Query
from pydantic import conint

from models import (
    CreateActionRequest,
    CreateActionResponse,
    CreateBundleRequest,
    CreateBundleResponse,
    CreateCalendarEventRequest,
    CreateCalendarEventResponse,
    CreateCalendarEventResponseRequest,
    CreateGroupRequest,
    CreateGroupResponse,
    CreateOrUpdateErrorResponse,
    CreatePatientHealthMetricRequest,
    CreatePatientHealthMetricResponse,
    CreatePatientRequest,
    CreatePatientResponse,
    CreateRewardEarningFulfillmentRequest,
    CreateRewardEarningFulfillmentResponse,
    CreateRewardEarningRequest,
    CreateRewardEarningResponse,
    CreateRewardProgramActivationRequest,
    CreateRewardProgramActivationResponse,
    CreateRewardProgramRequest,
    CreateRewardProgramResponse,
    CreateRewardRequest,
    CreateRewardResponse,
    CreateTokenRequest,
    CreateTokenResponse,
    FetchActionResponse,
    FetchBundleResponse,
    FetchCalendarEventResponse,
    FetchCalendarEventsResponse,
    FetchCoachesResponse,
    FetchCoachResponse,
    FetchEmailHistoriesResponse,
    FetchEmailHistoryResponse,
    FetchErrorResponse,
    FetchGroupResponse,
    FetchGroupsResponse,
    FetchHealthProfileAnswerResponse,
    FetchHealthProfileAnswersResponse,
    FetchHealthProfileQuestionResponse,
    FetchHealthProfileQuestionsResponse,
    FetchHealthProfileResponse,
    FetchHealthProfilesResponse,
    FetchHealthQuestionDefinitionResponse,
    FetchHealthQuestionDefinitionsResponse,
    FetchOrganizationResponse,
    FetchPatientHealthMetricResponse,
    FetchPatientHealthResultResponse,
    FetchPatientPlanSummariesResponse,
    FetchPatientPlanSummaryResponse,
    FetchPatientResponse,
    FetchPatientsResponse,
    FetchRewardEarningFulfillmentResponse,
    FetchRewardEarningFulfillmentsResponse,
    FetchRewardEarningResponse,
    FetchRewardEarningsResponse,
    FetchRewardProgramActivationResponse,
    FetchRewardProgramActivationsResponse,
    FetchRewardProgramResponse,
    FetchRewardProgramsResponse,
    FetchRewardResponse,
    FetchRewardsResponse,
    FilterType,
    Include,
    Include2,
    Include6,
    Include10,
    Include14,
    Include16,
    Sort,
    UpdateActionRequest,
    UpdateActionResponse,
    UpdateBundleRequest,
    UpdateBundleResponse,
    UpdateCalendarEventRequest,
    UpdateCalendarEventResponse,
    UpdatePatientPlanSummaryRequest,
    UpdatePatientPlanSummaryResponse,
    UpdatePatientRequest,
    UpdatePatientResponse,
    UpsertPatientRequest,
)

app = MCPProxy(
    contact={'email': 'apiteam@twinehealth.com'},
    description='# Overview\nThe Fitbit Plus API is a RESTful API. The requests and responses are formated according to the\n[JSON API](http://jsonapi.org/format/1.0/) specification.\n\nIn addition to this documentation, we also provide an\n[OpenAPI](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md) "yaml" file describing the API:\n[Fitbit Plus API Specification](swagger.yaml).\n\n# Authentication\nAuthentication for the Fitbit Plus API is based on the\n[OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749). Fitbit Plus currently supports grant\ntypes of **client_credentials** and **refresh_token**.\n\nSee [POST /oauth/token](#operation/createToken) for details on the request and response formats.\n<!-- ReDoc-Inject: <security-definitions> -->\n\n## Building Integrations\nWe will provide customers with unique client credentials for each application/integration they build, allowing us\nto enforce appropriate access controls and monitor API usage.\nThe client credentials will be scoped to the organization, and allow full access to all patients and related data\nwithin that organization.\n\nThese credentials are appropriate for creating an integration that does one of the following:\n - background reporting/analysis\n - synchronizing data with another system (such as an EMR)\n\nThe API credentials and oauth flows we currently support are **not** well suited for creating a user-facing\napplication that allows a user (patient, coach, or admin) to login and have access to data which is appropriate to\nthat specific user. It is possible to build such an application, but it is not possible to use Fitbit Plus as a\nfederated identity provider. You would need to have a separate means of verifying a user\'s identity. We do not\ncurrently support the required password-based oauth flow to make this possible.\n\n# Paging\nThe Fitbit Plus API supports two different pagination strategies for GET collection endpoints.\n\n#### Skip-based paging\n\nSkip-based paging uses the query parameters `page[size]` and `page[number]` to specify the max number of resources returned and the page number. We default to skip-based paging if there are no page parameters. The response will include a `links` object containing links to the first, last, prev, and next pages of data.\n\nIf the contents of the collection change while you are iterating through the collection, you will see duplicate or missing documents. For example, if you are iterating through the `calender_event` resource via `GET /pub/calendar_event?sort=start_at&page[size]=50&page[number]=1`, and a new `calendar_event` is created that has a `start_at` value before the first `calendar_event`, when you fetch the next page at `GET /pub/calendar_event?sort=start_at&page[size]=50&page[number]=2`, the first entry in the second response will be a duplicate of the last entry in the first response.\n\n#### Cursor-based paging\nCursor-based paging uses the query parameters `page[limit]` and `page[after]` to specify the max number of entries returned and identify where to begin the next page. Add `page[limit]` to the parameters to use cursor-based paging. The response will include a `links` object containing a link to the next page of data, if the next page exists.\n\nCursor-based paging is not subject to duplication if new resources are added to the collection. For example, if you are iterating through the `calender_event` resource via `GET /pub/calendar_event?sort=start_at&page[limit]=50`, and a new `calendar_event` is created that has a `start_at` value before the first `calendar_event`, you will not see a duplicate entry when you fetch the next page at `GET /pub/calendar_event?sort=start_at&page[limit]=50&page[after]=<cursor>`.\n\nWe encourage the use of cursor-based paging for performance reasons.\n\nIn either form of paging, you can determine whether any resources were missed by comparing the number of fetched resources against `meta.count`. Set `page[size]` or `page[limit]` to 0 to get only the count.\n\nIt is not valid to mix the two strategies.\n',
    title='Fitbit Plus API',
    version='v7.78.1',
    servers=[{'url': 'https://api.twinehealth.com/pub'}],
)


@app.post(
    '/action', description=""" Create a plan action """, tags=['action_management']
)
def create_action(body: CreateActionRequest):
    """
    Create action
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/action/{id}',
    description=""" Get a health action from a patient's plan. """,
    tags=['action_management'],
)
def fetch_action(id: str):
    """
    Get an action
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/action/{id}',
    description=""" Update a health action from a patient's plan. """,
    tags=['action_management'],
)
def update_action(id: str, body: UpdateActionRequest = ...):
    """
    Update an action
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/bundle',
    description=""" Create a bundle in a patient's plan """,
    tags=['bundle_management'],
)
def create_bundle(body: CreateBundleRequest):
    """
    Create bundle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bundle/{id}',
    description=""" Get a bundle from a patient's plan. """,
    tags=['bundle_management'],
)
def fetch_bundle(id: str):
    """
    Get a bundle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/bundle/{id}',
    description=""" Updte a bundle from a patient's plan. """,
    tags=['bundle_management'],
)
def update_bundle(id: str, body: UpdateBundleRequest = ...):
    """
    Update a bundle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calendar_event',
    description=""" Get a list of calendar events """,
    tags=['calendar_event_management', 'organization_data_management'],
)
def fetch_calendar_events(
    filter_patient_: Optional[str] = Query(None, alias='filter[patient]'),
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
    filter_attendees_: Optional[str] = Query(None, alias='filter[attendees]'),
    filter_type_: Optional[FilterType] = Query(None, alias='filter[type]'),
    filter_completed_: Optional[bool] = Query(None, alias='filter[completed]'),
    filter_start_at_: Optional[str] = Query(None, alias='filter[start_at]'),
    filter_end_at_: Optional[str] = Query(None, alias='filter[end_at]'),
    filter_completed_at_: Optional[str] = Query(None, alias='filter[completed_at]'),
    filter_created_at_: Optional[str] = Query(None, alias='filter[created_at]'),
    filter_updated_at_: Optional[str] = Query(None, alias='filter[updated_at]'),
    page_number_: Optional[int] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=0, le=50)] = Query(10, alias='page[size]'),
    page_limit_: Optional[conint(ge=0)] = Query(50, alias='page[limit]'),
    page_cursor_: Optional[str] = Query(None, alias='page[cursor]'),
    include: Optional[Include] = None,
):
    """
    List calendar events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calendar_event',
    description=""" Create a calendar event for a patient. Attribute `all_day` must be set to `true` and `end_at` cannot be set for `plan-check-in` event type. """,
    tags=['calendar_event_management'],
)
def create_calendar_event(body: CreateCalendarEventRequest):
    """
    Create calendar event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/calendar_event/{id}',
    description=""" Delete a calendar event by id """,
    tags=['calendar_event_management'],
)
def delete_calendar_event(id: str):
    """
    Delete a calendar event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calendar_event/{id}',
    description=""" Get a calendar event by id """,
    tags=['calendar_event_management', 'action_management'],
)
def fetch_calendar_event(id: str):
    """
    Get a calendar event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/calendar_event/{id}',
    description=""" Update a calendar event for a patient. Attribute `all_day` must be true and `end_at` cannot be specified for `plan-check-in` event type. To mark a calendar event as 'completed', set `completed_at` and `completed_by` to desired values.  To mark a completed calendar event as 'not completed', set `completed_at` and `completed_by` to `null`. Attendees can be added or removed, but response status cannot be updated. Use the calendar event response api for response status updates instead. """,
    tags=['calendar_event_management'],
)
def update_calendar_event(id: str, body: UpdateCalendarEventRequest = ...):
    """
    Update a calendar event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calendar_event_response',
    description=""" Create a calendar event response for an attendee of a calendar event, the attendee can be a coach or patient.  Calendar event responses cannot be fetched, updated nor deleted.  Use calendar event api to fetch the response status for attendees. """,
    tags=['calendar_event_management'],
)
def create_calendar_event_response(body: CreateCalendarEventResponseRequest):
    """
    Create calendar event response
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/coach',
    description=""" Get a list of coaches matching the specified filters. """,
    tags=['coach_information_management'],
)
def fetch_coaches(
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
):
    """
    List coaches
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/coach/{id}',
    description=""" Get a coach record by id. """,
    tags=['coach_information_management'],
)
def fetch_coach(id: str):
    """
    Get a coach
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/email_history',
    description=""" Get a list of email histories """,
    tags=['email_history_retrieval'],
)
def fetch_email_histories(
    filter_receiver_: Optional[str] = Query(None, alias='filter[receiver]'),
    filter_sender_: Optional[str] = Query(None, alias='filter[sender]'),
    filter_email_type_: Optional[str] = Query(None, alias='filter[emailType]'),
    sort: Optional[Sort] = None,
):
    """
    List email histories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/email_history/{id}',
    description=""" Get an email history by id """,
    tags=['email_history_retrieval'],
)
def fetch_email_history(id: str):
    """
    Get an email history
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/group',
    description=""" Get a list of groups matching the specified filters. """,
    tags=['group_operations', 'organization_data_management'],
)
def fetch_groups(
    filter_organization_: str = Query(..., alias='filter[organization]'),
    filter_name_: Optional[str] = Query(None, alias='filter[name]'),
):
    """
    List groups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/group', description=""" Create a group record. """, tags=['group_operations']
)
def create_group(body: CreateGroupRequest):
    """
    Create a group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/group/{id}',
    description=""" Get a group record by id. """,
    tags=['group_operations'],
)
def fetch_group(id: str):
    """
    Get a group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health_profile',
    description=""" Get a list of health profiles """,
    tags=['health_profile_handling', 'patient_record_management'],
)
def fetch_health_profiles(
    filter_patient_: Optional[str] = Query(None, alias='filter[patient]'),
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
    page_number_: Optional[int] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=0, le=50)] = Query(10, alias='page[size]'),
    page_limit_: Optional[conint(ge=0)] = Query(50, alias='page[limit]'),
    page_cursor_: Optional[str] = Query(None, alias='page[cursor]'),
    include: Optional[Include2] = None,
):
    """
    List health profiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health_profile/{id}',
    description=""" Get a health profile by id """,
    tags=['health_profile_handling'],
)
def fetch_health_profile(id: str, include: Optional[Include2] = None):
    """
    Get a health profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health_profile_answer',
    description=""" Get a list of health profile answers """,
    tags=[
        'health_profile_handling',
        'patient_health_results_retrieval',
        'patient_health_metrics_management',
    ],
)
def fetch_health_profile_answers(
    filter_patient_: Optional[str] = Query(None, alias='filter[patient]'),
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
    page_number_: Optional[int] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=0, le=100)] = Query(50, alias='page[size]'),
    page_limit_: Optional[conint(ge=0)] = Query(50, alias='page[limit]'),
    page_cursor_: Optional[str] = Query(None, alias='page[cursor]'),
    include: Optional[Include6] = None,
):
    """
    List health profile answers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health_profile_answer/{id}',
    description=""" Get a health profile answer by id """,
    tags=['health_profile_handling'],
)
def fetch_health_profile_answer(id: str, include: Optional[Include6] = None):
    """
    Get a health profile answer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health_profile_question',
    description=""" Get a list of health profile questions """,
    tags=['health_profile_handling'],
)
def fetch_health_profile_questions(
    filter_patient_: Optional[str] = Query(None, alias='filter[patient]'),
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
    include: Optional[Include10] = None,
):
    """
    List health profile questions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health_profile_question/{id}',
    description=""" Get a health profile by id """,
    tags=['health_profile_handling'],
)
def fetch_health_profile_question(id: str, include: Optional[Include10] = None):
    """
    Get a health profile question
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health_question_definition',
    description=""" Get a list of all health question definitions """,
    tags=['health_profile_handling'],
)
def fetch_health_question_definitions():
    """
    List health question definitions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health_question_definition/{id}',
    description=""" Get a health question definition by id """,
    tags=['health_profile_handling'],
)
def fetch_health_question_definition(id: str):
    """
    Get a health question definition
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/oauth/token',
    description=""" Create an OAuth 2.0 Bearer token. A valid bearer token is required for all other API requests.

Be sure to set the header `Content-Type: "application/vnd.api+json"`. Otherwise, you will get an error
403 Forbidden. Using `Content-Type: "application/json"` is permitted (to support older oauth clients) but when
using `application/json` the body should have a body in the following format instead of nesting under
`data.attributes`:
```
{
  "grant_type": "client_credentials",
  "client_id": "95c78ab2-167f-40b8-8bec-8398d4b87454",
  "client_secret": "35d18dc9-a3dd-4948-b787-063a490b9354"
}
```
 """,
    tags=['oauth_token_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_token(include: Optional[Include14] = None, body: CreateTokenRequest = ...):
    """
    Create an oauth token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/oauth/token/{id}/groups',
    description=""" Get the list of groups a token can be used to access. """,
    tags=['group_operations', 'oauth_token_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def fetch_token_groups(id: str):
    """
    Get the groups for a token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/oauth/token/{id}/organization',
    description=""" Get the organization a token can be used to access. """,
    tags=['organization_data_management', 'oauth_token_management'],
)
def fetch_token_organization(id: str):
    """
    Get the organization for a token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organization/{id}',
    description=""" Get an organization record by id. """,
    tags=['organization_data_management'],
)
def fetch_organization(id: str):
    """
    Get an organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/patient',
    description=""" Get a list of patients. """,
    tags=['patient_record_management', 'organization_data_management'],
)
def fetch_patients(
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
    filter_identifier__system_: Optional[str] = Query(
        None, alias='filter[identifier][system]'
    ),
    filter_identifier__value_: Optional[str] = Query(
        None, alias='filter[identifier][value]'
    ),
    filter_archived_: Optional[bool] = Query(None, alias='filter[archived]'),
    filter_created_at_: Optional[str] = Query(None, alias='filter[created_at]'),
    filter_updated_at_: Optional[str] = Query(None, alias='filter[updated_at]'),
    page_number_: Optional[int] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=0, le=50)] = Query(10, alias='page[size]'),
    page_limit_: Optional[conint(ge=0)] = Query(50, alias='page[limit]'),
    page_cursor_: Optional[str] = Query(None, alias='page[cursor]'),
):
    """
    List patients
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/patient',
    description=""" Create a patient record.

Example for creating a patient with a group specified using `meta.query` instead of `id`:

```JSON
{
  "data": {
    "type": "patient",
    "attributes": {
      "first_name": "Andrew",
      "last_name": "Smith"
    },
    "relationships": {
      "groups": {
        "data": [
          {
            "type": "group",
            "meta": {
              "query": {
                "organization": "58c88de7c93eb96357a87033",
                "name": "Patients Lead"
              }
            }
          }
        ]
      }
    }
  }
}
```
 """,
    tags=['patient_record_management'],
)
def create_patient(body: CreatePatientRequest):
    """
    Create a patient
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/patient',
    description=""" Create a new patient or update an existing patient """,
    tags=['patient_record_management'],
)
def upsert_patient(body: UpsertPatientRequest):
    """
    Upsert patient
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/patient/{id}',
    description=""" Gets a patient record by id. """,
    tags=['patient_record_management'],
)
def fetch_patient(id: str):
    """
    Get a patient
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/patient/{id}',
    description=""" Update a patient record. """,
    tags=['patient_record_management'],
)
def update_patient(id: str, body: UpdatePatientRequest = ...):
    """
    Update a patient
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/patient/{id}/coaches',
    description=""" Get the list of coaches for a patient. """,
    tags=['coach_information_management'],
)
def fetch_patient_coaches(id: str):
    """
    List coaches for a patient
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/patient/{id}/groups',
    description=""" Get the list of groups for a patient. """,
    tags=['group_operations', 'patient_record_management'],
)
def fetch_patient_groups(id: str):
    """
    List groups for a patient
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/patient_health_metric',
    description=""" Get a list of patient health metrics. """,
    tags=['patient_health_metrics_management', 'patient_health_results_retrieval'],
)
def fetch_patient_health_metrics(
    filter_patient_: Optional[str] = Query(None, alias='filter[patient]'),
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
    page_number_: Optional[int] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=0, le=50)] = Query(10, alias='page[size]'),
    page_limit_: Optional[conint(ge=0)] = Query(50, alias='page[limit]'),
    page_cursor_: Optional[str] = Query(None, alias='page[cursor]'),
):
    """
    List patient health metrics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/patient_health_metric',
    description=""" Create one or more patient health metrics.

Example for creating a patient health result with a patient specified using `meta.query` instead of `id`:

```JSON
  {
    "data": {
      "type": "patient_health_metric",
       "attributes": {
         "code": {
           "system": "LOINC",
           "value": "13457-7"
         },
         "type": "ldl_cholesterol",
         "occurred_at": "2017-03-14T11:00:57.000Z",
         "value": 121,
         "unit": "mg/dl"
      },
      "relationships": {
        "patient": {
          "data": {
            "type": "patient",
            "meta": {
              "query": {
                "identifier": {
                  "system": "medical-record-number",
                  "value": "121212"
                },
                "organization": "58c4554710123c5c40dbab81"
              }
            }
          }
        }
      }
    }
  }
```
 """,
    tags=['patient_health_metrics_management', 'patient_record_management'],
)
def create_patient_health_metric(body: CreatePatientHealthMetricRequest):
    """
    Create patient health metrics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/patient_health_metric/{id}',
    description=""" Get the plan summary for a patient. """,
    tags=['patient_health_metrics_management', 'patient_health_results_retrieval'],
)
def fetch_patient_health_metric(id: str):
    """
    Get a patient health metric
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/patient_plan_summary',
    description=""" Get a list of patient plan summaries """,
    tags=['patient_plan_overview_management', 'patient_record_management'],
)
def fetch_patient_plan_summaries(
    filter_patient_: Optional[str] = Query(None, alias='filter[patient]'),
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
    include: Optional[Include16] = None,
):
    """
    List patient plan summaries
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/patient_plan_summary/{id}',
    description=""" Get the plan summary for a patient. """,
    tags=['patient_plan_overview_management', 'patient_record_management'],
)
def fetch_patient_plan_summary(id: str, include: Optional[Include16] = None):
    """
    Get the plan summary for a patient
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/patient_plan_summary/{id}',
    description=""" Update a plan summary record for a patient. """,
    tags=['patient_plan_overview_management', 'action_management'],
)
def update_patient_plan_summary(id: str, body: UpdatePatientPlanSummaryRequest = ...):
    """
    Update a plan summary
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/result',
    description=""" Get a list of patient health results. """,
    tags=[
        'patient_health_results_retrieval',
        'patient_health_metrics_management',
        'patient_record_management',
    ],
)
def fetch_patient_health_results(
    filter_patient_: str = Query(..., alias='filter[patient]'),
    filter_actions_: Optional[str] = Query(None, alias='filter[actions]'),
    filter_start_at_: Optional[str] = Query(None, alias='filter[start_at]'),
    filter_end_at_: Optional[str] = Query(None, alias='filter[end_at]'),
    filter_threads_: Optional[str] = Query(None, alias='filter[threads]'),
    filter_created_at_: Optional[str] = Query(None, alias='filter[created_at]'),
    filter_updated_at_: Optional[str] = Query(None, alias='filter[updated_at]'),
    page_number_: Optional[int] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=0, le=50)] = Query(10, alias='page[size]'),
    page_limit_: Optional[conint(ge=0)] = Query(50, alias='page[limit]'),
    page_after_: Optional[str] = Query(None, alias='page[after]'),
):
    """
    List patient health results
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/result/{id}',
    description=""" Get patient health result by id. """,
    tags=[
        'patient_health_results_retrieval',
        'health_profile_handling',
        'patient_record_management',
    ],
)
def fetch_patient_health_result(id: str):
    """
    Get a patient health result
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward',
    description=""" Get a list of rewards matching the specified filters. """,
    tags=['reward_management', 'reward_program_activation_management'],
)
def fetch_rewards(
    filter_patient_: Optional[str] = Query(None, alias='filter[patient]'),
    filter_reward_program_activation_: Optional[str] = Query(
        None, alias='filter[reward_program_activation]'
    ),
    filter_thread_: Optional[str] = Query(None, alias='filter[thread]'),
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
):
    """
    List rewards
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reward',
    description=""" Create a reward for a patient. """,
    tags=['reward_management'],
)
def create_reward(body: CreateRewardRequest):
    """
    Create a reward
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward/{id}',
    description=""" Get a reward record by id. """,
    tags=['reward_management'],
)
def fetch_reward(id: str):
    """
    Get a reward
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward_earning',
    description=""" Get a list of reward earnings matching the specified filters. """,
    tags=['reward_management'],
)
def fetch_reward_earnings(
    filter_groups_: str = Query(..., alias='filter[groups]'),
    filter_patient_: str = Query(..., alias='filter[patient]'),
    filter_ready_for_fulfillment_: Optional[bool] = Query(
        None, alias='filter[ready_for_fulfillment]'
    ),
):
    """
    List reward earnings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reward_earning',
    description=""" Create a reward earning for a reward. There can only be one earning for a reward. It is possilble to create multiple reward earnings simultaneously by providing and array of reward earnings in the data property. """,
    tags=['reward_management'],
)
def create_reward_earning(body: CreateRewardEarningRequest):
    """
    Create a reward earning
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward_earning/{id}',
    description=""" Get a reward earning record by id. """,
    tags=['reward_management'],
)
def fetch_reward_earning(id: str):
    """
    Get a reward earning
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward_earning_fulfillment',
    description=""" Get a list of reward earning fulfillments matching the specified filters. """,
    tags=['reward_management'],
)
def fetch_reward_earning_fulfillments(
    filter_patient_: str = Query(..., alias='filter[patient]')
):
    """
    List reward earning fulfillments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reward_earning_fulfillment',
    description=""" Create a reward earning fulfillment for a reward earning. There can only be one fulfillment for each earning. """,
    tags=['reward_management'],
)
def create_reward_earning_fulfillment(body: CreateRewardEarningFulfillmentRequest):
    """
    Create a reward earning fulfillment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward_earning_fulfillment/{id}',
    description=""" Get a reward earning fulfillment record by id. """,
    tags=['reward_management'],
)
def fetch_reward_earning_fulfillment(id: str):
    """
    Get a reward earning fulfillment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward_program',
    description=""" Get a list of reward programs matching the specified filters. """,
    tags=['reward_management', 'reward_program_activation_management'],
)
def fetch_reward_programs(
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
):
    """
    List reward programs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reward_program',
    description=""" Create a reward program for a group. """,
    tags=['reward_management', 'reward_program_activation_management'],
)
def create_reward_program(body: CreateRewardProgramRequest):
    """
    Create a reward program
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward_program/{id}',
    description=""" Get a reward program record by id. """,
    tags=['reward_management', 'reward_program_activation_management'],
)
def fetch_reward_program(id: str):
    """
    Get a reward program
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward_program/{id}/group',
    description=""" Get the group related to a reward program. """,
    tags=['reward_management', 'reward_program_activation_management'],
)
def fetch_reward_program_group(id: str):
    """
    Get group for a reward program
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward_program_activation',
    description=""" Get a list of reward program activations matching the specified filters. """,
    tags=['reward_management', 'reward_program_activation_management'],
)
def fetch_reward_program_activations(
    filter_patient_: Optional[str] = Query(None, alias='filter[patient]'),
    filter_groups_: Optional[str] = Query(None, alias='filter[groups]'),
    filter_organization_: Optional[str] = Query(None, alias='filter[organization]'),
):
    """
    List reward program activations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reward_program_activation',
    description=""" Create a reward program activation for a patient. There can only be one activation for a patient for a given reward program. """,
    tags=['reward_management', 'reward_program_activation_management'],
)
def create_reward_program_activation(body: CreateRewardProgramActivationRequest):
    """
    Create a reward program activation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reward_program_activation/{id}',
    description=""" Get a reward program activationrecord by id. """,
    tags=['reward_program_activation_management', 'reward_management'],
)
def fetch_reward_program_activation(id: str):
    """
    Get a reward program activation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
